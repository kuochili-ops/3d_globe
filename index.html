<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D Duck Globe Fix</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; height: 100vh; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* ä»‹é¢æ¨£å¼ - åƒè€ƒæ‚¨çš„æˆªåœ–å¾®èª¿ */
        #app-ui { 
            position: absolute !important; bottom: 0 !important; left: 0 !important; width: 100% !important; z-index: 1000 !important; 
            background: rgba(10, 10, 10, 0.95) !important; padding: 15px 0 env(safe-area-inset-bottom) !important;
            display: flex !important; flex-direction: column !important; align-items: center !important;
            border-top: 1px solid #333 !important;
        }
        #app-ui.viewer-mode { display: none !important; }

        .ui-content { width: 92%; max-width: 500px; display: flex; flex-direction: column; gap: 10px; }
        .ui-row { display: flex; width: 100%; gap: 8px; align-items: center; }
        
        select, input[type="text"] { 
            background: #000; border: 1.5px solid #00ffff; color: #fff; padding: 12px; border-radius: 8px; 
            font-size: 14px; outline: none; flex: 1;
        }
        input[type="color"] { width: 45px; height: 45px; background: none; border: 1.5px solid #00ffff; border-radius: 8px; cursor: pointer; padding: 2px; }
        
        .btn { padding: 12px; border-radius: 8px; font-weight: bold; border: none; cursor: pointer; font-size: 14px; }
        .share-btn { background: #3b82f6; color: white; flex: 2; }
        .upload-btn { background: #333; color: white; flex: 1; }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div id="app-ui">
    <div class="ui-content">
        <div class="ui-row">
            <select id="modelSelect">
                <option value="https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb">ç¶“å…¸å°é´¨</option>
            </select>
            <input type="color" id="colorPicker" value="#00ffff">
            <input type="text" id="textInput" value="HELLO DUCK" placeholder="è¼¸å…¥æ–‡å­—...">
        </div>
        <div class="ui-row">
            <button class="btn share-btn" id="shareBtn">ğŸ”— åˆ†äº«é©šå–œç¦®ç‰© (æ”¶è¨Šè€…ç„¡ä»‹é¢)</button>
            <button class="btn upload-btn" id="uploadBtn">ğŸ“‚ ä¸Šå‚³ GLB</button>
        </div>
    </div>
</div>

<input type="file" id="real-file" accept=".glb,.gltf" style="display:none;">

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    let scene, camera, renderer, controls, snowSystem;
    let charGroups = [], snowVelocities = [];
    let isMoving = false, moveTimer = 0;
    const globeY = 1.6;

    async function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        camera.position.set(0, 3, 6);
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, globeY, 0);
        controls.addEventListener('change', () => { isMoving = true; moveTimer = 25; });

        // å…‰æºå¼·åŒ–
        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(5, 10, 5);
        scene.add(sun);

        // æ°´æ™¶çƒ - é™ä½é€æ˜åº¦ä»¥é˜²é®æ“‹æ–‡å­—
        const globe = new THREE.Mesh(
            new THREE.SphereGeometry(1.5, 32, 32),
            new THREE.MeshPhysicalMaterial({ transmission: 1, thickness: 0.05, transparent: true, opacity: 0.1 })
        );
        globe.position.y = globeY;
        scene.add(globe);

        // é›ªèŠ±
        const snowGeo = new THREE.BufferGeometry();
        const posArr = [];
        for (let i = 0; i < 1000; i++) {
            posArr.push((Math.random()-0.5)*2.2, 0.25, (Math.random()-0.5)*2.2);
            snowVelocities.push(new THREE.Vector3(0,0,0));
        }
        snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(posArr, 3));
        snowSystem = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.02 }));
        scene.add(snowSystem);

        // åˆå§‹åŒ–æ–‡å­—
        updateText();
        
        // è¼‰å…¥å°é´¨
        loadModel(document.getElementById('modelSelect').value);

        animate();
    }

    function updateText() {
        const textStr = document.getElementById('textInput').value || " ";
        const color = document.getElementById('colorPicker').value;

        charGroups.forEach(g => scene.remove(g));
        charGroups = [];

        textStr.split('').forEach((char, i) => {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.font = 'bold 90px sans-serif'; // ä½¿ç”¨ç³»çµ±å­—é«”
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(char, 64, 64);

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide, depthTest: false }); // é—œéµï¼šé—œé–‰æ·±åº¦æ¸¬è©¦
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(0.35, 0.35), mat);
            
            const g = new THREE.Group();
            g.add(mesh);
            g.renderOrder = 999; // ç¢ºä¿æ–‡å­—åœ¨æœ€å¾Œæ¸²æŸ“
            scene.add(g);
            charGroups.push(g);
        });
    }

    function loadModel(url) {
        new GLTFLoader().load(url, (gltf) => {
            if (window.currentModel) scene.remove(window.currentModel);
            window.currentModel = gltf.scene;
            const box = new THREE.Box3().setFromObject(window.currentModel);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const scale = 1.0 / Math.max(size.x, size.y, size.z);
            window.currentModel.scale.setScalar(scale);
            window.currentModel.position.set(-center.x*scale, globeY - center.y*scale, -center.z*scale);
            scene.add(window.currentModel);
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        
        const pos = snowSystem.geometry.attributes.position.array;
        for (let i = 0; i < 1000; i++) {
            const ix = i*3, iy = i*3+1, iz = i*3+2;
            if (isMoving && Math.random() > 0.95) {
                snowVelocities[i].set((Math.random()-0.5)*0.04, Math.random()*0.06, (Math.random()-0.5)*0.04);
            }
            pos[ix] += snowVelocities[i].x; pos[iy] += snowVelocities[i].y; pos[iz] += snowVelocities[i].z;
            snowVelocities[i].y -= 0.0008;
            if (pos[iy] < 0.25) { pos[iy] = 0.25; snowVelocities[i].set(0,0,0); }
            const d = Math.sqrt(pos[ix]**2 + (pos[iy]-globeY)**2 + pos[iz]**2);
            if (d > 1.48) snowVelocities[i].multiplyScalar(-0.4);
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;
        if (moveTimer > 0) moveTimer--; else isMoving = false;

        const time = Date.now() * 0.0012;
        charGroups.forEach((g, i) => {
            const angle = time - (i / charGroups.length) * Math.PI * 2;
            g.position.set(Math.cos(angle)*1.44, globeY, Math.sin(angle)*1.44);
            g.lookAt(0, globeY, 0); g.rotateY(Math.PI);
        });

        if (window.currentModel) window.currentModel.rotation.y += 0.005;
        controls.update();
        renderer.render(scene, camera);
    }

    // äº‹ä»¶ç›£è½
    document.getElementById('textInput').oninput = updateText;
    document.getElementById('colorPicker').oninput = updateText;
    document.getElementById('uploadBtn').onclick = () => document.getElementById('real-file').click();
    document.getElementById('real-file').onchange = (e) => {
        const file = e.target.files[0];
        if (file) loadModel(URL.createObjectURL(file));
    };
    document.getElementById('shareBtn').onclick = () => {
        const t = encodeURIComponent(document.getElementById('textInput').value);
        const c = document.getElementById('colorPicker').value.replace('#','');
        const url = `${window.location.origin}${window.location.pathname}?t=${t}&c=${c}&view=1`;
        navigator.clipboard.writeText(url).then(() => alert('é€£çµå·²è¤‡è£½ï¼å‚³çµ¦æœ‹å‹å³å¯éš±è—ä»‹é¢ã€‚'));
    };

    if (new URLSearchParams(window.location.search).get('view') === '1') {
        document.getElementById('app-ui').classList.add('viewer-mode');
    }

    init();
</script>
</body>
</html>
