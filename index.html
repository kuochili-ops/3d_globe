<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Crystal Ball - Natural Snow Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; }
        #ui-layer {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: "Microsoft JhengHei", sans-serif;
            pointer-events: none;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>3D 水晶球展示</h1>
    <p>拖曳旋轉 • 滾輪縮放</p>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // --- 初始化場景 ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1, 4);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- 燈光配置 ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 15);
    pointLight.position.set(2, 3, 2);
    scene.add(pointLight);

    // --- 水晶球外殼模組 ---
    function createCrystalBall() {
        const ballGroup = new THREE.Group();

        // 外層透明玻璃
        const glassGeom = new THREE.SphereGeometry(2, 64, 64);
        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0,
            roughness: 0,
            transmission: 0.95,
            thickness: 0.5,
            transparent: true,
            opacity: 0.3,
            envMapIntensity: 1.5
        });
        const glassSphere = new THREE.Mesh(glassGeom, glassMat);
        ballGroup.add(glassSphere);

        // 底座
        const baseGeom = new THREE.CylinderGeometry(1.2, 1.5, 0.5, 32);
        const baseMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.2 });
        const base = new THREE.Mesh(baseGeom, baseMat);
        base.position.y = -1.8;
        ballGroup.add(base);

        scene.add(ballGroup);
        return ballGroup;
    }

    createCrystalBall();

    // --- 升級版：自然隨機雪花模式 ---
    const snowCount = 1500;
    const snowGeometry = new THREE.BufferGeometry();
    const snowPositions = new Float32Array(snowCount * 3);
    const snowData = []; // 儲存每片雪花的物理特徵

    for (let i = 0; i < snowCount; i++) {
        // 在球體範圍內隨機分佈
        const r = Math.random() * 1.8;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;

        snowPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        snowPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        snowPositions[i * 3 + 2] = r * Math.cos(phi);

        snowData.push({
            speedY: 0.005 + Math.random() * 0.015,  // 下落速度
            drift: Math.random() * 0.02,           // 隨機漂移量
            phase: Math.random() * Math.PI * 2,    // 擺動初始相位
            wobble: 0.002 + Math.random() * 0.005  // 左右晃動幅度
        });
    }

    snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
    const snowMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.025,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });

    const snowPoints = new THREE.Points(snowGeometry, snowMaterial);
    scene.add(snowPoints);

    // --- 動畫邏輯 ---
    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;

        const positions = snowPoints.geometry.attributes.position.array;
        for (let i = 0; i < snowCount; i++) {
            const idx = i * 3;
            const data = snowData[i];

            // 1. 垂直下落
            positions[idx + 1] -= data.speedY;

            // 2. 增加隨機擾動 (漂浮感關鍵)
            positions[idx] += Math.sin(time + data.phase) * data.wobble;
            positions[idx + 2] += Math.cos(time + data.phase) * data.wobble;

            // 3. 水晶球邊界偵測 (當掉到底部或超出球體，重置到頂部)
            const dist = Math.sqrt(
                positions[idx]**2 + 
                positions[idx+1]**2 + 
                positions[idx+2]**2
            );

            if (positions[idx + 1] < -1.7 || dist > 1.9) {
                // 重置到球體上半部
                const r = Math.random() * 1.5;
                const theta = Math.random() * Math.PI * 2;
                positions[idx] = r * Math.cos(theta);
                positions[idx + 1] = 1.5 + Math.random() * 0.3;
                positions[idx + 2] = r * Math.sin(theta);
            }
        }
        snowPoints.geometry.attributes.position.needsUpdate = true;

        controls.update();
        renderer.render(scene, camera);
    }

    animate();

    // 視窗自適應
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- 載入模型功能預留 (保持原功能) ---
    // 你可以將產生的 GLB URL 填入此處
    /*
    const loader = new GLTFLoader();
    loader.load('YOUR_MODEL_LINK.glb', (gltf) => {
        const model = gltf.scene;
        model.scale.set(0.5, 0.5, 0.5);
        model.position.y = -1.5; // 放在底座上
        scene.add(model);
    });
    */

</script>
</body>
</html>
